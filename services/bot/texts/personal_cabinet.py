# services/bot/texts/personal_cabinet.py

"""
Формирование текста экрана «Личный кабинет».

Задача:
- собрать по данным из БД информацию о телефонах и банках;
- оформить её в Markdown (как используется в add_headline);
- учитывать флаг show_details (скрывать/показывать реквизиты);
- аккуратно переносить строки с сохранением отступов.
"""

from __future__ import annotations                               # Разрешаем "отложенные" аннотации типов (удобно для type hints)

import textwrap                                                  # Импортируем модуль textwrap для переноса строк
from typing import List                                          # Импортируем List для аннотаций типов

from ..database import get_user                                  # Импортируем функцию получения пользователя из "базы"
from ..tools.banks_wordbook import BANKS                         # Импортируем словарь банков (код -> данные банка)


# Эмодзи "белый квадратик" перед номером телефона
WHITE_SQUARE: str = "▫"                                          # Этот символ будет стоять перед каждой строкой телефона

# Максимальная длина строки перед ручным переносом
MAX_LINE_WIDTH: int = 30                                         # При превышении длины строки будем делать перенос


def _wrap_with_indent(line: str) -> str:
    """
    Переносим одну строку, сохраняя начальные отступы (пробелы/табы)
    и добавляя +2 пробела ко всем перенесённым строкам.

    Правила:
    - префиксом считаем все начальные символы ' ' или '\t';
    - первая строка (оригинал) идёт с этим префиксом как есть;
    - все последующие строки (после переноса) получают префикс + 2 пробела;
      при этом +2 берутся именно к ПЕРВОНАЧАЛЬНОМУ префиксу, а не к предыдущей перенесённой строке.

    Пример:
        строка: "    Сбербанк очень длинное название ..."
        префикс: "    "  (4 пробела)
        перенос: первая строка — с "    ",
                 все последующие — с "      " (6 пробелов).
    """
    prefix_chars: List[str] = []                                # Список для накопления символов префикса
    for ch in line:                                             # Проходим по символам строки слева направо
        if ch in (" ", "\t"):                                   # Если символ — пробел или табуляция
            prefix_chars.append(ch)                             # Добавляем его к префиксу
        else:
            break                                               # Как только наткнулись на "обычный" символ — прерываем цикл

    prefix: str = "".join(prefix_chars)                         # Склеиваем символы префикса в строку
    content: str = line[len(prefix):]                           # Отделяем "полезную" часть строки без префикса

    if len(content) <= MAX_LINE_WIDTH:                          # Если полезная часть и так короткая
        return line                                             # Возвращаем исходную строку без изменений

    # Строка длинная — делаем перенос.
    # Первая строка идёт с исходным префиксом,
    # все последующие — с префиксом + 2 пробела.
    wrapper = textwrap.TextWrapper(
        width=MAX_LINE_WIDTH,                                   # Максимальная длина строки (включая префикс)
        initial_indent=prefix,                                  # Отступ для первой строки
        subsequent_indent=prefix + "  ",                        # Отступ для всех последующих (префикс + 2 пробела)
        break_long_words=False,                                 # Не разрываем слова посреди
        break_on_hyphens=False,                                 # Не переносим по дефисам
    )

    wrapped: str = wrapper.fill(content)                        # Выполняем перенос содержательной части строки

    return wrapped                                              # Возвращаем результат (с префиксом и переносами)


def _mask_phone_for_markdown(phone: str) -> str:
    """
    Вернуть маску телефона для режима "реквизиты скрыты".

    Чтобы не ломать Markdown (последовательность *** может восприниматься как разметка),
    используем нейтральную маску "ХХХ 12-34" без звёздочек.

    Пример:
        phone = "+79991234455" -> "ХХХ 4455"
    """
    tail = phone[-4:] if len(phone) >= 4 else phone             # Берём последние 4 символа (или весь номер, если он короче)
    masked_part = f"ХХХ {tail}"                                 # Формируем строку маски: "ХХХ 4455"
    return masked_part                                          # Возвращаем маску без Markdown-символов


def _format_bank_title(bank_code: str, is_main: bool) -> str:
    """
    Вернуть строку для одной строки банка.

    Требования:
    - каждый банк начинается с четырёх пробелов;
    - основной банк выделяется курсивом (*...*) и пометкой "(основной)";
    - обычный банк — просто текст.

    Примеры:
        обычный: "    Сбербанк"
        основной: "    *Т-Банк (основной)*"
    """
    bank = BANKS.get(bank_code)                                 # Пытаемся найти описание банка по его коду
    if bank is not None:                                        # Если банк найден в словаре
        title = (                                               # Пытаемся взять осмысленное название
            bank.get("message_title")                           # Сначала message_title
            or bank.get("button_title")                         # потом button_title
            or bank_code                                        # если ничего нет — используем код банка
        )
    else:
        title = bank_code                                       # Если банк вообще не найден — используем код

    if is_main:                                                 # Если это основной банк
        return f"    *{title} (основной)*"                      # 4 пробела + курсив с пометкой "(основной)"
    else:
        return f"    {title}"                                   # 4 пробела + обычный текст (без форматирования)


def build_personal_cabinet_text(
    user_id: int,                                               # ID пользователя в Telegram
    show_details: bool,                                         # Флаг: показывать ли реквизиты целиком
) -> str:
    """
    Сформировать текст экрана «Личный кабинет» для заданного пользователя.

    Возвращается строка с разметкой Markdown, уже разбитая на строки с учётом отступов и переносов.
    """
    user = get_user(user_id)                                   # Получаем объект пользователя из файловой "базы"

    lines: List[str] = []                                      # Список логических строк будущего сообщения

    # --- Заголовок экрана --- #

    lines.append("*Ваши платежные реквизиты*")                 # Добавляем заголовок, выделенный курсивом (Markdown)
    lines.append("")                                           # Добавляем пустую строку-разделитель

    # --- Случай, когда у пользователя нет телефонов --- #

    if not user.phones:                                        # Если у пользователя ещё нет сохранённых телефонов
        lines.append("У вас пока нет сохранённых реквизитов.") # Добавляем информативную строку
        # Пропускаем через переносчик, чтобы не потерять отступы (хотя их тут и нет)
        wrapped_lines = [_wrap_with_indent(line) for line in lines]
        return "\n".join(wrapped_lines)                        # Склеиваем строки через '\n' и возвращаем готовый текст

    # --- Перебираем все телефоны пользователя --- #
    # user.phones — словарь вида: { "номер": PhoneData }

    for phone, phone_data in user.phones.items():              # Итерируемся по парам (номер телефона, данные по нему)

        # Формируем строку с телефоном в зависимости от флага show_details
        if show_details:                                       # Если реквизиты должны отображаться полностью
            phone_line = f"*{WHITE_SQUARE} Телефон {phone}:*"  # Пример: "*▫ Телефон +79991234455:*"
        else:                                                  # Если реквизиты нужно скрыть
            masked = _mask_phone_for_markdown(phone)           # Получаем маску вида "ХХХ 4455"
            phone_line = f"*{WHITE_SQUARE} Телефон {masked}:*" # Пример: "*▫ Телефон ХХХ 4455:*"

        lines.append(phone_line)                               # Добавляем строку с телефоном в общий список

        # Получаем список банков для этого телефона
        banks = list(phone_data.banks or [])                   # Берём список кодов банков (или пустой список)
        main_bank = phone_data.main_bank                       # Код основного банка (или None)

        # --- Если для телефона не выбраны банки --- #

        if not banks:                                          # Если список банков пуст
            lines.append("    (банки не выбраны)")             # Добавляем строку с 4 пробелами и пояснением
            lines.append("")                                   # Пустая строка-разделитель между телефонами
            continue                                           # Переходим к следующему номеру телефона

        # --- Формируем строки по каждому банку --- #

        for bank_code in banks:                                # Итерируемся по кодам банков
            is_main = (main_bank is not None) and (bank_code == main_bank)
            # is_main = True, если этот банк является основным для текущего телефона

            bank_line = _format_bank_title(bank_code, is_main) # Формируем строку для банка (с нужным отступом и форматированием)
            lines.append(bank_line)                            # Добавляем строку банка в список

        lines.append("")                                       # После списка банков добавляем пустую строку для отделения телефонов

    # --- Применяем переносы строк с сохранением отступов --- #

    wrapped_lines = [                                          # Для каждой логической строки
        _wrap_with_indent(line)                                # применяем функцию переноса с учётом отступов
        for line in lines
    ]

    # Склеиваем все строки в один текст через '\n' и возвращаем
    return "\n".join(wrapped_lines)
