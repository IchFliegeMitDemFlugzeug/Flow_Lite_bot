# -*- coding: utf-8 -*-  # Указываем кодировку файла, чтобы корректно работать с кириллицей

"""
Парсер текстового запроса для INLINE-режима бота.

Примеры входа (raw_query — то, что после @bot_bot):
    "500"
    "500 Сбер"
    "500 скинь, пожалуйста, на Т-банк как обычно"
    "Сбер"
    "ХуйБанк"
    "500 ПСБ зарплата за декабрь"

Наша задача:
1) Найти сумму перевода (если есть) — первую последовательность цифр.
2) Найти банк в большом сообщении:
   - пробегаемся по всему тексту;
   - для каждого банка из BANKS берём:
       * code          (например, "mkb"),
       * button_title  ("МКБ"),
       * message_title ("Московский Кредитный Банк");
   - сравниваем без учёта регистра, пробелов, дефисов и прочих символов.
3) Сохранить «кандидата» банка, даже если его нет в словаре:
   - нужно для сценариев типа "@bot_bot ХуйБанк".
"""

from __future__ import annotations                      # Разрешаем "отложенные" аннотации типов (удобно для type hints)

import re                                                # Модуль регулярных выражений — ищем числа, чистим текст
from dataclasses import dataclass                       # dataclass — компактное описание структуры результата
from typing import Optional                             # Optional[T] = T | None для читаемых аннотаций

from ..banks_wordbook import BANKS                    # Наш словарь банков: code, button_title, message_title и т.д.


# ------------------------- #
#   МОДЕЛЬ РЕЗУЛЬТАТА ПАРСЕРА
# ------------------------- #


@dataclass
class ParsedInlineQuery:
    """
    Результат разбора inline-запроса.

    Поля:
        raw_query      — исходный текст (как пришёл от Telegram).
        amount         — сумма перевода (int) или None.
        bank_code      — внутренний код банка из BANKS (например, "sber", "tbank") или None.
        bank_candidate — текст-кандидат на банк (когда банк не найден в словаре).
    """
    raw_query: str                                      # Оригинальный текст запроса
    amount: Optional[int]                               # Найденная сумма или None
    bank_code: Optional[str]                            # Код банка из словаря или None
    bank_candidate: Optional[str]                       # Текст-кандидат (для неизвестных банков) или None


# ------------------------- #
#   ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
# ------------------------- #


def _normalize_bank_text(text: str) -> str:
    """
    Нормализуем строку для сравнения с названиями банков.

    Делаем:
    - приводим к нижнему регистру;
    - заменяем 'ё' на 'е';
    - убираем пробелы, дефисы, точки, запятые, кавычки, скобки.

    Примеры:
        "Т-Банк"                     -> "тбанк"
        "   Т Банк "                 -> "тбанк"
        "Московский Кредитный Банк"  -> "московскийкредитныйбанк"
        "ПСБ"                        -> "псб"
    """
    text = (text or "").lower()                       # Приводим к нижнему регистру, защищаемся от None
    text = text.replace("ё", "е")                     # Убираем различие между "е" и "ё"
    # Удаляем пробелы, дефисы, точки, запятые, кавычки и скобки
    text = re.sub(r"[\s\-\.,\"'«»()]+", "", text)
    return text                                       # Возвращаем нормализованный текст


def _strip_amount_tokens(raw: str) -> str:
    """
    Удаляем из строки фрагменты, похожие на "сумму с валютой".

    Ищем паттерны:
        "500"
        "500р"
        "500 р"
        "500руб"
        "500 rub"
        "500₽"
        "500 руб."
    и заменяем их на пробел, чтобы при поиске банка они не мешали.

    Примеры:
        "500 Сбер"                 -> " Сбер"
        "500р  ПСБ зарплата"      -> "  ПСБ зарплата"
        "Сбер 700р как обычно"    -> "Сбер  как обычно"
    """
    return re.sub(
        r"\d+\s*(?:р|p|руб|rub|₽)?\.?",               # Число + необязательное обозначение валюты
        " ",                                         # Заменяем найденное на пробел
        raw,
        flags=re.IGNORECASE,                         # Игнорируем регистр при поиске "руб"/"rub"
    )


def _extract_amount(raw: str) -> Optional[int]:
    """
    Ищем сумму перевода в строке.

    Логика (простая, как обсуждали):
    - находим ПЕРВУЮ последовательность цифр;
    - считаем её суммой;
    - всё остальное игнорируем.

    Примеры:
        "500"                      -> 500
        "500р"                     -> 500
        "500 ₽ Сбер"              -> 500
        "Сбер 700р как обычно"    -> 700
        "Сбер"                    -> None
    """
    if not raw:                                      # Если строка пустая — суммы нет
        return None

    match = re.search(r"\d+", raw)                   # Ищем первую группу цифр
    if not match:                                    # Если цифр не нашли
        return None                                  # Считаем, что суммы нет

    digits = match.group(0)                          # Берём найденные цифры как строку

    try:
        return int(digits)                           # Пробуем превратить строку в int
    except ValueError:                               # На всякий случай ловим ошибку
        return None                                  # В случае ошибки возвращаем None


def _extract_bank_candidate_without_dict(raw: str) -> Optional[str]:
    """
    Выделяем текст-кандидат на банк БЕЗ использования словаря BANKS.

    Нужен для сценариев, когда банк НЕ найден в словаре, но пользователь
    явно что-то написал (например, "ХуйБанк").

    Логика:
    - убираем сумму/валюту из строки;
    - сжимаем пробелы;
    - если что-то осталось — возвращаем как candidate.

    Минус: если пользователь напишет целое предложение,
    candidate может содержать не только банк, но это ок для первых версий.
    """
    if not raw:                                      # Пустой ввод — кандидата нет
        return None

    without_amount = _strip_amount_tokens(raw)       # Выкидываем числа + валюту
    # Схлопываем повторяющиеся пробелы и обрезаем края
    candidate = re.sub(r"\s+", " ", without_amount).strip()

    return candidate or None                         # Пустую строку превращаем в None


def _detect_bank_code_from_full_text(raw: str) -> Optional[str]:
    """
    Находим банк в ПОЛНОМ тексте сообщения, используя словарь BANKS.

    Алгоритм:
    1) Удаляем из текста сумму/валюту (чтобы не мешали).
    2) Нормализуем весь текст (_normalize_bank_text).
    3) Для каждого банка из BANKS:
        - берём code, button_title, message_title;
        - нормализуем каждое поле;
        - если norm_variant содержится в norm_text ИЛИ наоборот
          (norm_text в norm_variant) — считаем, что банк найден.

    Примеры:
        "Сбер"                          -> "sber"
        "сбербанк"                      -> "sber"
        "500 Т-Банк зарплата"          -> "tbank"
        "500р Московский Кредитный"    -> "mkb"
    """
    if not raw:                                      # Пустой ввод — банк найти нельзя
        return None

    text_without_amount = _strip_amount_tokens(raw)  # Убираем суммы и валюту
    norm_text = _normalize_bank_text(text_without_amount)  # Нормализуем всё, что осталось

    if not norm_text:                                # Если текст полностью "съели"
        return None                                  # Считаем, что банка нет

    # Перебираем все банки из словаря
    for bank_data in BANKS.values():
        # Собираем все варианты строк, по которым будем искать совпадения
        variants = [
            bank_data.get("code") or "",             # Внутренний код (например, "mkb")
            bank_data.get("button_title") or "",     # Название на кнопке (например, "МКБ")
            bank_data.get("message_title") or "",    # Полное название (например, "Московский Кредитный Банк")
        ]

        for variant in variants:                     # Перебираем варианты одной записи банка
            norm_variant = _normalize_bank_text(variant)  # Нормализуем вариант

            if not norm_variant:                     # Пустые варианты пропускаем
                continue

            # Считаем совпаданием любой вариант подстрочного включения:
            # - "сбер" содержится в "сбербанк"
            # - "московскийкредитныйбанк" == "московскийкредитныйбанк"
            if norm_variant in norm_text or norm_text in norm_variant:
                return bank_data.get("code")         # Возвращаем код банка (например, "mkb")

    # Если ни один банк не подошёл — возвращаем None
    return None


# ------------------------- #
#   ОСНОВНАЯ ФУНКЦИЯ ПАРСИНГА
# ------------------------- #


def parse_inline_query(raw_query: Optional[str]) -> ParsedInlineQuery:
    """
    Главная функция, которую будут вызывать inline-хэндлеры.

    Вход:
        raw_query — строка из InlineQuery.query (может быть None или пустой).

    Выход:
        ParsedInlineQuery:
            raw_query      — исходный текст;
            amount         — сумма или None;
            bank_code      — код банка из BANKS или None;
            bank_candidate — текст-кандидат на банк или None.

    Функция НЕ бросает исключений — в худшем случае вернёт всё None,
    кроме raw_query (там будет хотя бы пустая строка).
    """
    safe_raw = (raw_query or "").strip()             # Гарантируем строку и убираем пробелы по краям

    # --- Шаг 1. Ищем сумму перевода --- #
    amount = _extract_amount(safe_raw)               # Находим первую группу цифр

    # --- Шаг 2. Ищем банк в ПОЛНОМ сообщении по словарю BANKS --- #
    bank_code = _detect_bank_code_from_full_text(safe_raw)  # Пытаемся сопоставить с известными банками

    # --- Шаг 3. Формируем текст-кандидат на банк --- #
    if bank_code is None:                            # Если банк не распознан по словарю
        bank_candidate = _extract_bank_candidate_without_dict(safe_raw)  # Пробуем вытащить текст
    else:
        # Если банк найден, candidate нам не нужен — дальше используем bank_code и BANKS[bank_code]
        bank_candidate = None

    # Собираем dataclass с результатом и возвращаем его хэндлеру
    return ParsedInlineQuery(
        raw_query=safe_raw,
        amount=amount,
        bank_code=bank_code,
        bank_candidate=bank_candidate,
    )
