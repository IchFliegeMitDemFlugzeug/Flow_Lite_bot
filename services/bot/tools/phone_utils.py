# -*- coding: utf-8 -*-  # Указываем кодировку файла, чтобы корректно работать с кириллицей в комментариях и строках

"""
Вспомогательные функции для работы с НОМЕРАМИ ТЕЛЕФОНОВ.

Используем библиотеку `phonenumbers` (порт Google libphonenumber),
НО с дополнительным ограничением: нас интересуют ТОЛЬКО российские номера.

Критерий "теоретически номер может быть российским":
- библиотека успешно парсит номер;
- у распарсенного номера country_code == 7;
- номер валиден (или хотя бы возможен) для региона "RU".

То есть:
    +7 999 123-45-67   -> принимаем
    8 (999) 123-45-67  -> принимаем (станет +79991234567)
    9991234567         -> принимаем (как российский локальный номер, +7 добавится)

    +1 234 555 6688    -> ОТКЛОНЯЕМ (это не Россия, country_code == 1)
"""

import phonenumbers                             # Импортируем внешнюю библиотеку phonenumbers (нужно установить через pip)
from phonenumbers import (                      # Из неё импортируем конкретные сущности, которые будем использовать
    PhoneNumberMatcher,                         # Класс, который умеет искать номера в произвольном тексте
    PhoneNumberFormat,                          # Перечисление форматов вывода номера
    NumberParseException,                       # Исключение, которое выбрасывается при ошибках парсинга
)

from aiogram.types import Message               # Импортируем тип Message из aiogram для аннотаций функций


# Константа с регионом по умолчанию для парсинга номеров.
# "RU" — означает, что libphonenumber будет трактовать локальные номера (без +7) как российские.
DEFAULT_REGION = "RU"                           # Двубуквенный код страны по ISO 3166-1 alpha-2 (в нашем случае Россия)


def _parsed_is_russian_number(parsed: phonenumbers.phonenumber.PhoneNumber) -> bool:
    """
    Вспомогательная функция: проверяем, что РАСПАРСЕННЫЙ номер действительно российский.

    Условия:
    - parsed.country_code == 7                     — международный код России;
    - номер валиден ДЛЯ РЕГИОНА "RU".

    На выходе:
    - True, если номер можно считать российским;
    - False, если номер другой страны или просто не подходит под формат РФ.
    """
    if parsed.country_code != 7:                 # Если код страны НЕ равен 7 (то есть номер не российский)
        return False                             # Сразу возвращаем False — нас такой номер не интересует

    # Проверяем валидность номера именно для России.
    # Можно использовать is_possible_number_for_region(...) для более "мягкой" проверки.
    if not phonenumbers.is_valid_number_for_region(parsed, "RU"):  # Если номер невалиден для региона "RU"
        return False                             # Тоже считаем, что он нам не подходит

    return True                                  # Во всех остальных случаях — это корректный российский номер


def normalize_phone(raw: str, default_region: str = DEFAULT_REGION) -> str | None:
    """
    Приводим сырую строку raw к международному формату E.164 (+79991234567),
    НО только если этот номер можно считать российским.

    Примеры:
        "8 (999) 123-45-67"      -> "+79991234567"
        "+7 999 123-45-67"       -> "+79991234567"
        "9991234567"             -> "+79991234567" (при default_region="RU")

        "+1 234 555 6688"        -> None  (НЕ Россия, country_code != 7)

    Параметры:
        raw            — исходная строка, в которой предположительно содержится номер;
        default_region — регион по умолчанию для парсинга "локальных" форматов (например, 8ххх, 9ххх).

    Возвращаем:
        Строку вида "+79991234567" — если номер успешно распознан и является российским;
        None — если распознать не удалось или номер не РФ.
    """
    raw = (raw or "").strip()                   # Безопасно приводим raw к строке и удаляем пробелы по краям
    if not raw:                                 # Если после этого строка пустая
        return None                             # Считаем, что номера нет

    try:
        parsed = phonenumbers.parse(            # Пытаемся распарсить номер
            raw,                                # Исходная строка
            default_region,                     # Регион по умолчанию (важен для локальных форматов)
        )
    except NumberParseException:                # Если при парсинге возникла ошибка
        return None                             # Возвращаем None — номер распознать не удалось

    if not _parsed_is_russian_number(parsed):   # Проверяем, что номер действительно российский
        return None                             # Если нет — сразу отбрасываем

    # На этом этапе parsed — валидный российский номер, можно формировать строку в формате E.164.
    e164 = phonenumbers.format_number(          # Преобразуем распарсенный номер в строку
        parsed,                                 # Объект распарсенного номера
        PhoneNumberFormat.E164,                 # Формат E.164 — всегда "+<код_страны><цифры>"
    )

    return e164                                 # Возвращаем нормализованный российский номер


def extract_phone_from_text(text: str, default_region: str = DEFAULT_REGION) -> str | None:
    """
    Ищем ПЕРВЫЙ валидный РОССИЙСКИЙ номер телефона в произвольном тексте.

    Сценарии:
    - пользователь прислал одно сообщение с несколькими номерами — берём первый, который:
        * корректно парсится
        * и является российским (country_code == 7 и валиден для "RU");
    - пользователь прислал сообщение с кучей мусора и одним номером внутри — вычленяем его;
    - если matcher ничего не нашёл, но весь текст похож на один номер — пробуем normalize_phone(text).

    Параметры:
        text           — произвольный текст, в котором могут быть номера;
        default_region — регион по умолчанию для парсинга (обычно "RU").

    Возвращаем:
        Строку в формате E.164 (например, "+79991234567") — если нашли российский номер;
        None — если ничего подходящего не нашли.
    """
    if not text:                              # Если текст None или пустая строка
        return None                           # Ничего искать не будем, сразу возвращаем None

    # Создаём объект PhoneNumberMatcher, который пройдётся по всему тексту
    # и найдёт все последовательности, похожие на номера.
    matcher = PhoneNumberMatcher(
        text,                                 # Текст, в котором нужно искать
        default_region,                       # Регион по умолчанию для локальных форматов
    )

    for match in matcher:                     # Перебираем все найденные совпадения
        parsed = match.number                 # Берём распарсенный объект номера из совпадения

        if not _parsed_is_russian_number(parsed):  # Проверяем, что это РОССИЙСКИЙ номер
            continue                          # Если нет — пропускаем и смотрим следующие совпадения

        # Если сюда дошли — parsed уже прошёл все проверки и является валидным номером РФ.
        e164 = phonenumbers.format_number(    # Форматируем его в строку
            parsed,                           # Распарсенный номер
            PhoneNumberFormat.E164,           # Формат "+79991234567"
        )
        return e164                           # Сразу возвращаем ПЕРВЫЙ подходящий российский номер

    # Если matcher не нашёл ни одного подходящего российского номера,
    # есть шанс, что весь текст — это один номер (например, "9991234567").
    return normalize_phone(                   # Пробуем нормализовать весь текст как "один номер"
        text,                                 # Исходный текст целиком
        default_region=default_region,        # Регион по умолчанию
    )                                        # Если и тут не получится — normalize_phone вернёт None


def extract_phone_from_message(
    message: Message,                         # Объект входящего сообщения из aiogram
    default_region: str = DEFAULT_REGION,     # Регион по умолчанию, по которому интерпретируем локальные номера
) -> str | None:
    """
    Универсальная точка входа для хэндлеров бота.

    Логика:
    1) Если пользователь отправил контакт (кнопка "Отправить номер телефона") —
       берём message.contact.phone_number, нормализуем и проверяем, что это российский номер.
    2) Иначе, если есть текст — пытаемся найти российский номер в тексте (через PhoneNumberMatcher).
    3) Если ни контакта, ни текста нет — возвращаем None.

    Параметры:
        message        — объект Message, который пришёл в хэндлер;
        default_region — регион по умолчанию (для локальных форматов без кода страны).

    Возвращаем:
        Строку в формате E.164 (например, "+79991234567"), если номер РФ найден;
        None — если номер не найден или не является российским.
    """

    # 1. Проверяем, не отправил ли пользователь контакт.
    if message.contact and message.contact.phone_number:   # Если в сообщении есть contact и в нём есть phone_number
        raw_phone = message.contact.phone_number           # Берём "сырой" номер из контакта
        return normalize_phone(                            # Пытаемся нормализовать его как российский
            raw_phone,                                     # Исходная строка с номером
            default_region=default_region,                 # Регион по умолчанию
        )

    # 2. Если контакта нет, но есть текст — пробуем найти номер в тексте.
    if message.text:                                       # Проверяем, есть ли текстовое содержимое сообщения
        return extract_phone_from_text(                    # Ищем российский номер внутри текста
            message.text,                                  # Сам текст сообщения
            default_region=default_region,                 # Регион по умолчанию
        )

    # 3. Если ни текста, ни контакта — вернуть нечего.
    return None                                            # Сообщаем хэндлеру, что номер определить не удалось
