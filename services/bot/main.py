import asyncio  # Импортируем модуль asyncio — нужен для запуска асинхронного цикла событий (event loop)
import os       # Импортируем модуль os — из него будем брать переменную окружения с токеном бота

from aiogram import Bot, Dispatcher  # Bot — клиент Telegram, Dispatcher — распределяет апдейты по хэндлерам
from aiogram.fsm.storage.memory import MemoryStorage  # Памятное (in-memory) хранилище состояний FSM
from aiogram.client.default import DefaultBotProperties  # Класс для задания свойств бота по умолчанию

from .handlers.registration import (                    # Импортируем роутеры хэндлеров
    registration_router,                                # Роутер регистрации
)
from .handlers.personal_cabinet import (                # Импортируем роутер личного кабинета
    personal_cabinet_router,                            # Роутер экрана «Личный кабинет»
)
from bot.tools.global_guard import (                    # Импортируем глобальный роутер-фильтр
    global_guard_router,                                # Роутер, который чистит "левые" сообщения
)


async def main() -> None:
    """
    Главная асинхронная функция приложения.
    Здесь создаём бота, диспетчер, регистрируем роутеры и запускаем polling.
    """

    # Получаем токен бота из переменной окружения BOT_TOKEN.
    # Никакой переменной BOT_TOKEN в коде больше нет — всё берётся только из окружения,
    # которое ты укажешь в настройках конфигурации запуска PyCharm.
    token = os.getenv("BOT_TOKEN")  # os.getenv возвращает строку с токеном или None, если переменная не задана

    # Проверяем, что токен действительно найден в окружении.
    # Если переменная не задана (token is None или пустая строка), выбрасываем исключение —
    # чтобы сразу увидеть понятную ошибку при запуске, а не молча падать где-то внутри aiogram.
    if not token:  # Условие сработает, если token == None, "" или любая "ложная" строка
        raise RuntimeError(
            "Переменная окружения BOT_TOKEN не задана. "
            "Укажи её в настройках конфигурации запуска (Run/Debug) в PyCharm."
        )

    # Создаём объект Bot — это обёртка над Telegram Bot API, через него отправляются сообщения, читаются апдейты и т.д.
    # Параметр token — строка с токеном твоего бота, полученная у BotFather и переданная через окружение.
    # default=DefaultBotProperties(...) — задаём свойства по умолчанию:
    #   parse_mode="Markdown" — все сообщения будут интерпретироваться Телеграмом как Markdown-разметка.
    bot = Bot(
        token=token,  # Используем токен, который взяли из переменной окружения BOT_TOKEN
        default=DefaultBotProperties(parse_mode="Markdown"),  # Устанавливаем режим форматирования текста по умолчанию
    )

    # Создаём хранилище состояний (Finite State Machine).
    # MemoryStorage — все данные FSM хранятся в оперативной памяти текущего процесса.
    # Подходит для разработки и тестов; для продакшена обычно используют Redis/Bd-хранилище.
    storage = MemoryStorage()

    # Создаём Dispatcher — центральный объект, который принимает апдейты от бота
    # и передаёт их в соответствующие роутеры/хэндлеры в зависимости от фильтров.
    dp = Dispatcher(storage=storage)  # Передаём наше хранилище для работы FSM

    # Регистрируем роутер регистрации в диспетчере.
    # Теперь все хэндлеры, объявленные внутри registration_router, будут активны.
    dp.include_router(registration_router)
    dp.include_router(personal_cabinet_router)  # Активируем хэндлеры экрана «Личный кабинет»
    dp.include_router(global_guard_router)  # И ТОЛЬКО ПОТОМ подключаем глобальный роутер-фильтр
    # Важно: он должен быть последним, чтобы не перехватывать сообщения раньше нужных хэндлеров

    # Запускаем long-polling — бесконечный цикл, в котором бот опрашивает серверы Telegram
    # на наличие новых апдейтов (сообщений, нажатий кнопок и т.д.).
    # dp.start_polling сам будет вызывать зарегистрированные хэндлеры по мере прихода апдейтов.
    await dp.start_polling(bot)


# Этот блок выполняется только если файл запущен напрямую,
# а не импортирован как модуль из другого файла.
if __name__ == "__main__":
    # asyncio.run запускает нашу корутину main() в новом event loop’е
    # и блокирует текущий поток до её завершения.
    asyncio.run(main())
