# Импортируем модуль os, чтобы уметь читать переменные окружения
import os

# Импортируем dataclass, чтобы удобно хранить настройки в виде объекта
from dataclasses import dataclass


# Описываем структуру настроек бота с помощью dataclass
# dataclass автоматически создаёт конструктор и repr, нам не нужно писать их вручную
@dataclass
class BotConfig:
    # Поле для хранения токена бота, который выдаёт BotFather
    token: str


# Имя переменной окружения, в которой ожидаем токен бота
ENV_BOT_TOKEN_NAME: str = "BOT_TOKEN"


def load_bot_config() -> BotConfig:
    """
    Функция загрузки конфигурации бота из переменных окружения.

    1. Читает переменную окружения BOT_TOKEN.
    2. Проверяет, что она задана.
    3. Возвращает объект BotConfig с токеном.
    """

    # Читаем значение переменной окружения BOT_TOKEN.
    # Если переменная не установлена, os.getenv вернёт None.
    raw_token: str | None = os.getenv(ENV_BOT_TOKEN_NAME)

    # Проверяем, что токен действительно задан и не пустой строкой
    if not raw_token:
        # Формируем понятное сообщение об ошибке,
        # чтобы по логам сразу было видно, что именно не настроено
        message: str = (
            f"Переменная окружения {ENV_BOT_TOKEN_NAME!r} не задана. "
            f"Убедись, что в файле .env есть строка {ENV_BOT_TOKEN_NAME}=... "
            f"и что эта переменная передаётся в процесс бота (через Docker или настройки запуска)."
        )
        # Поднимаем исключение RuntimeError с этим сообщением
        raise RuntimeError(message)

    # Если токен успешно прочитан, создаём объект BotConfig
    config: BotConfig = BotConfig(token=raw_token)

    # Возвращаем объект с настройками
    return config
