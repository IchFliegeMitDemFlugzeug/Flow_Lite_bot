# services/bot/handlers/global_guard.py

from aiogram import Router                             # Импортируем Router для создания отдельного роутера
from aiogram.types import Message                      # Тип Message для входящих сообщений пользователя
from aiogram.fsm.context import FSMContext             # FSMContext для работы с состояниями пользователя

# Импортируем состояния, в которых МЫ СОЗНАТЕЛЬНО ЖДЁМ текст от пользователя.
# Пока у нас только регистрация, поэтому подключаем RegistrationStates.
from ..states.registration import RegistrationStates   # Набор состояний из блока регистрации


# Создаём отдельный "глобальный" роутер,
# который будет подключён ПОСЛЕДНИМ в главном файле бота.
global_guard_router = Router(name="global_guard")      # Даём осмысленное имя роутеру для удобной отладки


# Формируем множество состояний, в которых ТЕКСТ от пользователя РАЗРЕШЁН.
# В этих состояниях мы НЕ должны удалять сообщения.
ALLOWED_TEXT_STATES = {
    RegistrationStates.waiting_for_phone,              # В этом состоянии пользователь вводит или отправляет свой номер телефона
    RegistrationStates.no_banks,                       # В этом состоянии пользователь пишет название банка, которого нет в списке
    # Сюда позже можно ДОБАВЛЯТЬ другие состояния из других модулей,
    # если в них тоже ожидается текст от пользователя.
}


@global_guard_router.message()                         # Регистрируем хэндлер "на все сообщения" БЕЗ дополнительных фильтров
async def catch_unexpected_messages(
    message: Message,                                  # Объект сообщения от пользователя
    state: FSMContext,                                 # FSM-контекст (по нему узнаём текущее состояние пользователя)
) -> None:
    """
    Глобальный хэндлер-фильтр для всего бота.

    Логика:
    - Если пользователь сейчас находится в состоянии, где текст РАЗРЕШЁН (например, ввод номера),
      то мы НИЧЕГО не делаем и пропускаем сообщение дальше (или даём отработать другим хэндлерам).
    - Если состояние НЕ входит в список "разрешённых для текста", значит мы не ждём текст:
      тогда это "левое" сообщение (в т.ч. от dummy-кнопки), и мы его просто удаляем.
    """

    current_state: str | None = await state.get_state()  # Получаем текущее состояние пользователя в виде строки или None

    if current_state is None:                          # Если состояния нет вообще (пользователь вне FSM-сценариев)
        # В этой ситуации мы не берём на себя смелость удалять сообщения,
        # а просто выходим и даём другим хэндлерам (например, /start) отработать.
        return

    allowed_state_strings = {                          # Преобразуем объекты состояний в строки вида "registration:waiting_for_phone"
        st.state                                       # У каждого состояния есть свойство .state с полным строковым именем
        for st in ALLOWED_TEXT_STATES                  # Перебираем все разрешённые состояния
    }

    if current_state in allowed_state_strings:         # Если текущее состояние входит в список разрешённых
        # Значит, в этом состоянии текст от пользователя ОЖИДАЕТСЯ (например, он пишет номер телефона),
        # поэтому мы не вмешиваемся и не удаляем такие сообщения.
        return

    # Если мы дошли до этого места, то текущее состояние НЕ входит в ALLOWED_TEXT_STATES.
    # Значит, здесь мы НЕ планируем принимать текстовые сообщения от пользователя
    # (например, он должен пользоваться только инлайн-кнопками).
    # Любое сообщение считаем "левым" и пытаемся удалить.

    try:
        await message.delete()                         # Пытаемся удалить сообщение пользователя из чата
    except Exception:
        # Если по какой-то причине удалить сообщение не удалось (нет прав, сообщение уже удалено и т.п.),
        # то мы просто игнорируем ошибку, чтобы не уронить бота.
        pass
